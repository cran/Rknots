##HEADER##depends on bio3d (pdb import) and on RGL (3d graphics, to keep up) at the moment#To do, check if a class structure is well suited for a protein information set.#control input in the singleIntersection function#modify the arguments of msr, should be only of the points without indices as a default.edgeIntersections <-function (points3D, indiceslist, edgeindex) {    edgeintersections <- c()    maxindex <- length(indiceslist) - 1    if (edgeindex > maxindex)         warning("edgeindex > maxindex, call error")    if (edgeindex >= length(indiceslist))         warning("edgeindex out of bound, call error")    edgeindices <- indiceslist[edgeindex + c(0, 1)]    set <- indiceslist[-length(indiceslist)]    for (i in set) {        pointsij <- points3D[c(edgeindices, i, i + 1), ]        singleintersection <- singleIntersection(pointsij, "sign")        if (singleintersection != 0)             edgeintersections <- rbind(edgeintersections, c(i,                 singleintersection))    }    return(edgeintersections)}fileImport <-function (filename) {    if (missing(filename))         stop("fileImport: argument 'filename' missing, with no default\n")    if (!is.character(filename))         stop("fileImport: argument 'filename' must be string\n")        pdb <- read.pdb(filename)    chains <- unique(pdb$atom[, 5])    if(length(chains)!=1)    {    	cat(c("Available chains\n", chains))    	chain <- readline("Chain to read ")    }    else    {    	chain <- chains    }    pdb$atom <- pdb$atom[pdb$atom[, "chain"] == chain, ]    alphatrace <- pdb$atom[pdb$atom[, "elety"] == "CA", ]    coordinates <- matrix(as.double(alphatrace[, c("x","y","z")]), ncol = 3)    return(coordinates)}grm <-function (points3D, b, ends, inputM) {    M <- inputM    n <- nrow(points3D)    ncomp <- length(ends) + 1    shift <- 0    if (b >= (n - 1) || (b %in% ends))         return(list(points3D = points3D, ends = ends, M = M))    exends <- c(0, ends, n)    intervals <- list()    for (k in 1:ncomp) intervals[[k]] <- (exends[k] + 1):(exends[k +         1] - 1)    comp <- which(exends - b >= 0)[1] - 1    ecomponent <- exends[comp + 1]    tempM <- M    e <- b    while (e < (ecomponent - 1)) {        sh <- 0        e <- e + 1        range <- b:e        usubM <- M[range, range]        usubM[lower.tri(usubM)] <- 0        if ((min(usubM) * max(usubM) != -1) == TRUE) {            sh <- sh + 1            complement <- list()            for (k in 1:ncomp) complement[[k]] <- M[range, intervals[[k]]]            complement[[comp]] <- complement[[comp]][, intervals[[comp]][-which(intervals[[comp]] %in%                 (b:e) == TRUE)] - if (comp > 0) {                exends[comp]            }            else {                0            }]            complementsigns <- unique(unlist(complement))            if ((min(complementsigns) * max(complementsigns) != -1) == TRUE) {                sh <- sh + 1                temp <- edgeIntersections(points3D, c(1:n)[-((b +                   1):e)], b)                nr <- rep(0, n - 1)                nr[temp[, 1]] <- temp[, 2]                nrtemp <- nr                nrtemp[c(b, e)] <- 0                nrsigns <- unique(nrtemp)                cnd <- c(complementsigns, nrsigns)                if ((min(cnd) * max(cnd) !=                   -1) == TRUE) {                  sh <- sh + 1                  tempM <- M                  tempM[b, ] <- nr                  tempM[, b] <- (-nr)                  tempM <- tempM[-((b + 1):e), -((b + 1):e)]                }                else {                  break                }            }            else {                break            }        }        else {            break        }    }    if (sh == 3)         shift <- 1    drop <- shift + min(e - 1, ecomponent - 2)    if ((b + 1) <= drop) {        points3D <- points3D[-c((b + 1):drop), ]##HEADER##depends on bio3d (pdb import) and on RGL (3d graphics, to keep up) at the moment#To do, check if a class structure is well suited for a protein information set.edgeIntersections <-function (points3D, indiceslist, edgeindex) {    edgeintersections <- c()    maxindex <- length(indiceslist) - 1    if (edgeindex > maxindex)         warning("edgeindex > maxindex, call error")    if (edgeindex >= length(indiceslist))         warning("edgeindex out of bound, call error")    edgeindices <- indiceslist[edgeindex + c(0, 1)]    set <- indiceslist[-length(indiceslist)]    for (i in set) {        pointsij <- points3D[c(edgeindices, i, i + 1), ]        singleintersection <- singleIntersection(pointsij, "sign")        if (singleintersection != 0)             edgeintersections <- rbind(edgeintersections, c(i,                 singleintersection))    }    return(edgeintersections)}fileImport <-function (filename) {    if (missing(filename))         stop("fileImport: argument 'filename' missing, with no default\n")    if (!is.character(filename))         stop("fileImport: argument 'filename' must be string\n")        pdb <- read.pdb(filename)    chains <- unique(pdb$atom[, 5])    if(length(chains)!=1)    {    	cat(c("Available chains\n", chains))    	chain <- readline("Chain to read ")    }    else    {    	chain <- chains    }    pdb$atom <- pdb$atom[pdb$atom[, "chain"] == chain, ]    alphatrace <- pdb$atom[pdb$atom[, "elety"] == "CA", ]    coordinates <- matrix(as.double(alphatrace[, c("x","y","z")]), ncol = 3)    return(coordinates)}grm <-function (points3D, b, ends, inputM) {    M <- inputM    n <- nrow(points3D)    ncomp <- length(ends) + 1    shift <- 0    if (b >= (n - 1) || (b %in% ends))         return(list(points3D = points3D, ends = ends, M = M))    exends <- c(0, ends, n)    intervals <- list()    for (k in 1:ncomp) intervals[[k]] <- (exends[k] + 1):(exends[k +         1] - 1)    comp <- which(exends - b >= 0)[1] - 1    ecomponent <- exends[comp + 1]    tempM <- M    e <- b    while (e < (ecomponent - 1)) {        sh <- 0        e <- e + 1        range <- b:e        usubM <- M[range, range]        usubM[lower.tri(usubM)] <- 0        if ((min(usubM) * max(usubM) != -1) == TRUE) {            sh <- sh + 1            complement <- list()            for (k in 1:ncomp) complement[[k]] <- M[range, intervals[[k]]]            complement[[comp]] <- complement[[comp]][, intervals[[comp]][-which(intervals[[comp]] %in%                 (b:e) == TRUE)] - if (comp > 0) {                exends[comp]            }            else {                0            }]            complementsigns <- unique(unlist(complement))            if ((min(complementsigns) * max(complementsigns) != -1) == TRUE) {                sh <- sh + 1                temp <- edgeIntersections(points3D, c(1:n)[-((b +                   1):e)], b)                nr <- rep(0, n - 1)                nr[temp[, 1]] <- temp[, 2]                nrtemp <- nr                nrtemp[c(b, e)] <- 0                nrsigns <- unique(nrtemp)                cnd <- c(complementsigns, nrsigns)                if ((min(cnd) * max(cnd) !=                   -1) == TRUE) {                  sh <- sh + 1                  tempM <- M                  tempM[b, ] <- nr                  tempM[, b] <- (-nr)                  tempM <- tempM[-((b + 1):e), -((b + 1):e)]                }                else {                  break                }            }            else {                break            }        }        else {            break        }    }    if (sh == 3)         shift <- 1    drop <- shift + min(e - 1, ecomponent - 2)    if ((b + 1) <= drop) {        points3D <- points3D[-c((b + 1):drop), ]        ends[comp:(ncomp - 1)] <- ends[comp:(ncomp - 1)] - (drop -             b)        M <- tempM    }    return(list(points3D = points3D, ends = ends, M = M))}structurePlot <-function (points, ndim, color) {    if (ndim == 2) {        plot(points, type = "n", asp = 1)        lines(points, col = "blue")    }    {        lines3d(lwd = 3.5, color = color, points)        rgl.bringtotop()    }}intersectionMatrix <-function (points3D) {    nedge <- nrow(points3D) - 1    M <- matrix(0, nrow = nedge, ncol = nedge)    lintersectionslist <- list()    for (i in 1:nedge) {        lintersectionslist[[i]] <- edgeIntersections(points3D[1:(i +             1), ], 1:(i + 1), i)    }    nintersectionslist <- unlist(lapply(lintersectionslist, length))/2    intersecting <- which(nintersectionslist != 0)    natleastone <- length(intersecting)    nintersectionslist <- nintersectionslist[intersecting]    for (i in 1:natleastone) {        for (j in 1:nintersectionslist[i]) {            M[intersecting[i], lintersectionslist[[intersecting[i]]][j,                 1]] <- lintersectionslist[[intersecting[i]]][j,                 2]        }    }    return(M - t(M))}msr <-function (points3D, ends, n) {    M <- intersectionMatrix(points3D)    cat("matrix computed\n")    l <- quote(nrow(points3D))    k <- length(ends) + 1    for (i in 1:n) {        if (eval(l) <= 2 * k)             break        p <- nrow(points3D)        for (b in 1:(eval(l) - 1)) {            temp <- grm(points3D, b, ends, M)            points3D <- temp$points3D            ends <- temp$ends            M <- temp$M        }        if (p == eval(l))             break    }    return(list(points3D = points3D, ends = ends))}singleIntersection <-function (pointsij, kind) {    singleintersection <- 0    pointsij2D <- pointsij[, c(1, 2)]    vectors3D <- matrix(c(pointsij[2, ] - pointsij[1, ], pointsij[4,         ] - pointsij[3, ]), nrow = 2, byrow = T)    vectors2D <- vectors3D[, c(1, 2)]    if (nrow(unique(pointsij)) <= 3) {        return(singleintersection)    }    detv <- det(vectors2D)    if ((detv == 0) == TRUE) {        if (pointsij[1, ] == pointsij[2, ] || pointsij[3, ] ==             pointsij[4, ]) {            print("singleintersection::Exit due to collapsed edge")            return(singleintersection)        }        else {            if (rankMatrix(t(rbind(vectors2D, pointsij2D[3, ] -                 pointsij2D[1, ]))) == 1) {                ksi <- c(0, 0)                segment <- pointsij2D[2, ] - pointsij2D[1, ]                for (i in 1:2) ksi[i] <- segment %*% (pointsij2D[i +                   2, ] - pointsij2D[1, ])/(segment %*% segment)                if (((0 < ksi[1] && ksi[1] < 1) || (0 < ksi[2] &&                   ksi[2] < 1)) == TRUE) {                  warning("singleintersection::Superimposed edges")                  return(singleintersection)                }            }        }    }    else {        inverse <- matrix(c(vectors2D[2, 2], -vectors2D[2, 1],             vectors2D[1, 2], -vectors2D[1, 1]), nrow = 2, byrow = T)/detv        temp <- pointsij2D[3, ] - pointsij2D[1, ]        ks <- inverse %*% temp        conditionI <- ((0 < ks[1] && ks[1] < 1) && (0 < ks[2] &&             ks[2] < 1))        binary = (kind == "binary")        if (conditionI == TRUE && binary == TRUE) {            singleintersection <- 1            return(singleintersection)        }        if (conditionI == FALSE && binary == TRUE) {            singleintersection <- 0            return(singleintersection)        }        if (conditionI == TRUE && binary == FALSE) {            zs = c(pointsij[1, 3] + ks[1] * vectors3D[1, 3],                 pointsij[3, 3] + ks[2] * vectors3D[2, 3])            sign = sign(zs[1] - zs[2])            Qs = vectors3D            if (sign == 1) {                i <- 1                j <- 2            }            else {                i <- 2                j <- 1            }            Qs[i, ] <- pointsij[2 * i - 1, ] + ks[i] * vectors3D[i,                 ]            Qs[j, ] <- Qs[i, ]            Qs[j, 3] <- zs[j]            singleintersection <- switch(kind, sign = sign, q = list(sign = sign,                 Qs = Qs), k = list(sign = sign, ks = ks[1]),                 ks = list(sign = sign, ks = ks, Qs = Qs), lk = list(sign = sign,                   ks = ks[1], Q2D = Qs[1, 1:2], Qs = Qs), warning("Warning: switched called with uncorrect call option"))            return(singleintersection)        }        if (conditionI == FALSE && binary == FALSE)             singleintersection <- 0    }    return(singleintersection)}        ends[comp:(ncomp - 1)] <- ends[comp:(ncomp - 1)] - (drop -             b)        M <- tempM    }    return(list(points3D = points3D, ends = ends, M = M))}intersectionMatrix <-function (points3D) {    nedge <- nrow(points3D) - 1    M <- matrix(0, nrow = nedge, ncol = nedge)    lintersectionslist <- list()    for (i in 1:nedge) {        lintersectionslist[[i]] <- edgeIntersections(points3D[1:(i +             1), ], 1:(i + 1), i)    }    nintersectionslist <- unlist(lapply(lintersectionslist, length))/2    intersecting <- which(nintersectionslist != 0)    natleastone <- length(intersecting)    nintersectionslist <- nintersectionslist[intersecting]    for (i in 1:natleastone) {        for (j in 1:nintersectionslist[i]) {            M[intersecting[i], lintersectionslist[[intersecting[i]]][j,                 1]] <- lintersectionslist[[intersecting[i]]][j,                 2]        }    }    return(M - t(M))}msr <-function (points3D, ends, n) {    M <- intersectionMatrix(points3D)    cat("intersection matrix computed\n")    l <- quote(nrow(points3D))    k <- length(ends) + 1    for (i in 1:n) {        if (eval(l) <= 2 * k)             break        p <- nrow(points3D)        for (b in 1:(eval(l) - 1)) {            temp <- grm(points3D, b, ends, M)            points3D <- temp$points3D            ends <- temp$ends            M <- temp$M        }        if (p == eval(l))             break    }    cat("structure reduced\n")    return(list(points3D = points3D, ends = ends))}singleIntersection <-function (pointsij, kind) {    singleintersection <- 0    pointsij2D <- pointsij[, c(1, 2)]    vectors3D <- matrix(c(pointsij[2, ] - pointsij[1, ], pointsij[4,         ] - pointsij[3, ]), nrow = 2, byrow = T)    vectors2D <- vectors3D[, c(1, 2)]    if (nrow(unique(pointsij)) <= 3) {        return(singleintersection)    }    detv <- det(vectors2D)    if ((detv == 0) == TRUE) {        if (pointsij[1, ] == pointsij[2, ] || pointsij[3, ] ==             pointsij[4, ]) {            print("singleintersection::Exit due to collapsed edge")            return(singleintersection)        }        else {            if (rankMatrix(t(rbind(vectors2D, pointsij2D[3, ] -                 pointsij2D[1, ]))) == 1) {                ksi <- c(0, 0)                segment <- pointsij2D[2, ] - pointsij2D[1, ]                for (i in 1:2) ksi[i] <- segment %*% (pointsij2D[i +                   2, ] - pointsij2D[1, ])/(segment %*% segment)                if (((0 < ksi[1] && ksi[1] < 1) || (0 < ksi[2] &&                   ksi[2] < 1)) == TRUE) {                  warning("singleintersection::Superimposed edges")                  return(singleintersection)                }            }        }    }    else {        inverse <- matrix(c(vectors2D[2, 2], -vectors2D[2, 1],             vectors2D[1, 2], -vectors2D[1, 1]), nrow = 2, byrow = T)/detv        temp <- pointsij2D[3, ] - pointsij2D[1, ]        ks <- inverse %*% temp        conditionI <- ((0 < ks[1] && ks[1] < 1) && (0 < ks[2] &&             ks[2] < 1))        binary = (kind == "binary")        if (conditionI == TRUE && binary == TRUE) {            singleintersection <- 1            return(singleintersection)        }        if (conditionI == FALSE && binary == TRUE) {            singleintersection <- 0            return(singleintersection)        }        if (conditionI == TRUE && binary == FALSE) {            zs = c(pointsij[1, 3] + ks[1] * vectors3D[1, 3],                 pointsij[3, 3] + ks[2] * vectors3D[2, 3])            sign = sign(zs[1] - zs[2])            Qs = vectors3D            if (sign == 1) {                i <- 1                j <- 2            }            else {                i <- 2                j <- 1            }            Qs[i, ] <- pointsij[2 * i - 1, ] + ks[i] * vectors3D[i,                 ]            Qs[j, ] <- Qs[i, ]            Qs[j, 3] <- zs[j]            singleintersection <- switch(kind, sign = sign, q = list(sign = sign,                 Qs = Qs), k = list(sign = sign, ks = ks[1]),                 ks = list(sign = sign, ks = ks, Qs = Qs), lk = list(sign = sign,                   ks = ks[1], Q2D = Qs[1, 1:2], Qs = Qs), warning("Warning: switched called with uncorrect call option"))            return(singleintersection)        }        if (conditionI == FALSE && binary == FALSE)             singleintersection <- 0    }    return(singleintersection)}
library(rgl)library(bio3d)protein=fileImport("2k0a.pdb")head(protein)reduced=msr(protein,c(50),100)
getwd()
library(rgl)library(bio3d)setwd("/Users/comoglif/Documents/msR_Package_development")protein=fileImport("2k0a.pdb")head(protein)
reduced=msr(protein,c(50),100)
raceback()
traceback()
reduced=msr(protein,c(50),100)
traceback()
##HEADER##depends on bio3d (pdb import) and on RGL (3d graphics, to keep up) at the moment#To do, check if a class structure is well suited for a protein information set.#control input in the singleIntersection function#modify the arguments of msr, should be only of the points without indices as a default.edgeIntersections <-function (points3D, indiceslist, edgeindex) {    edgeintersections <- c()    maxindex <- length(indiceslist) - 1    if (edgeindex > maxindex)         warning("edgeindex > maxindex, call error")    if (edgeindex >= length(indiceslist))         warning("edgeindex out of bound, call error")    edgeindices <- indiceslist[edgeindex + c(0, 1)]    set <- indiceslist[-length(indiceslist)]    for (i in set) {        pointsij <- points3D[c(edgeindices, i, i + 1), ]        singleintersection <- singleIntersection(pointsij, "sign")        if (singleintersection != 0)             edgeintersections <- rbind(edgeintersections, c(i,                 singleintersection))    }    return(edgeintersections)}fileImport <-function (filename) {    if (missing(filename))         stop("fileImport: argument 'filename' missing, with no default\n")    if (!is.character(filename))         stop("fileImport: argument 'filename' must be string\n")        pdb <- read.pdb(filename)    chains <- unique(pdb$atom[, 5])    if(length(chains)!=1)    {    	cat(c("Available chains\n", chains))    	chain <- readline("Chain to read ")    }    else    {    	chain <- chains    }    pdb$atom <- pdb$atom[pdb$atom[, "chain"] == chain, ]    alphatrace <- pdb$atom[pdb$atom[, "elety"] == "CA", ]    coordinates <- matrix(as.double(alphatrace[, c("x","y","z")]), ncol = 3)    return(coordinates)}grm <-function (points3D, b, ends, inputM) {    M <- inputM    n <- nrow(points3D)    ncomp <- length(ends) + 1    shift <- 0    if (b >= (n - 1) || (b %in% ends))         return(list(points3D = points3D, ends = ends, M = M))    exends <- c(0, ends, n)    intervals <- list()        browser()        for (k in 1:ncomp) intervals[[k]] <- (exends[k] + 1):(exends[k +         1] - 1)    comp <- which(exends - b >= 0)[1] - 1    ecomponent <- exends[comp + 1]    tempM <- M    e <- b    while (e < (ecomponent - 1)) {        sh <- 0        e <- e + 1        range <- b:e        usubM <- M[range, range]        usubM[lower.tri(usubM)] <- 0        if ((min(usubM) * max(usubM) != -1) == TRUE) {            sh <- sh + 1            complement <- list()            for (k in 1:ncomp) complement[[k]] <- M[range, intervals[[k]]]            complement[[comp]] <- complement[[comp]][, intervals[[comp]][-which(intervals[[comp]] %in%                 (b:e) == TRUE)] - if (comp > 0) {                exends[comp]            }            else {                0            }]            complementsigns <- unique(unlist(complement))            if ((min(complementsigns) * max(complementsigns) != -1) == TRUE) {                sh <- sh + 1                temp <- edgeIntersections(points3D, c(1:n)[-((b +                   1):e)], b)                nr <- rep(0, n - 1)                nr[temp[, 1]] <- temp[, 2]                nrtemp <- nr                nrtemp[c(b, e)] <- 0                nrsigns <- unique(nrtemp)                cnd <- c(complementsigns, nrsigns)                if ((min(cnd) * max(cnd) !=                   -1) == TRUE) {                  sh <- sh + 1                  tempM <- M                  tempM[b, ] <- nr                  tempM[, b] <- (-nr)                  tempM <- tempM[-((b + 1):e), -((b + 1):e)]                }                else {                  break                }            }            else {                break            }        }        else {            break        }    }    if (sh == 3)         shift <- 1    drop <- shift + min(e - 1, ecomponent - 2)    if ((b + 1) <= drop) {        points3D <- points3D[-c((b + 1):drop), ]structurePlot <-function (points, ndim, color) {    if (ndim == 2) {        plot(points, type = "n", asp = 1)        lines(points, col = "blue")    }    {        lines3d(lwd = 3.5, color = color, points)        rgl.bringtotop()    }}intersectionMatrix <-function (points3D) {    nedge <- nrow(points3D) - 1    M <- matrix(0, nrow = nedge, ncol = nedge)    lintersectionslist <- list()    for (i in 1:nedge) {        lintersectionslist[[i]] <- edgeIntersections(points3D[1:(i +             1), ], 1:(i + 1), i)    }    nintersectionslist <- unlist(lapply(lintersectionslist, length))/2    intersecting <- which(nintersectionslist != 0)    natleastone <- length(intersecting)    nintersectionslist <- nintersectionslist[intersecting]    for (i in 1:natleastone) {        for (j in 1:nintersectionslist[i]) {            M[intersecting[i], lintersectionslist[[intersecting[i]]][j,                 1]] <- lintersectionslist[[intersecting[i]]][j,                 2]        }    }    return(M - t(M))}msr <-function (points3D, ends, n) {    M <- intersectionMatrix(points3D)    cat("matrix computed\n")    l <- quote(nrow(points3D))    k <- length(ends) + 1    for (i in 1:n) {        if (eval(l) <= 2 * k)             break        p <- nrow(points3D)        for (b in 1:(eval(l) - 1)) {            temp <- grm(points3D, b, ends, M)            points3D <- temp$points3D            ends <- temp$ends            M <- temp$M        }        if (p == eval(l))             break    }    return(list(points3D = points3D, ends = ends))}singleIntersection <-function (pointsij, kind) {    singleintersection <- 0    pointsij2D <- pointsij[, c(1, 2)]    vectors3D <- matrix(c(pointsij[2, ] - pointsij[1, ], pointsij[4,         ] - pointsij[3, ]), nrow = 2, byrow = T)    vectors2D <- vectors3D[, c(1, 2)]    if (nrow(unique(pointsij)) <= 3) {        return(singleintersection)    }    detv <- det(vectors2D)    if ((detv == 0) == TRUE) {        if (pointsij[1, ] == pointsij[2, ] || pointsij[3, ] ==             pointsij[4, ]) {            print("singleintersection::Exit due to collapsed edge")            return(singleintersection)        }        else {            if (rankMatrix(t(rbind(vectors2D, pointsij2D[3, ] -                 pointsij2D[1, ]))) == 1) {                ksi <- c(0, 0)                segment <- pointsij2D[2, ] - pointsij2D[1, ]                for (i in 1:2) ksi[i] <- segment %*% (pointsij2D[i +                   2, ] - pointsij2D[1, ])/(segment %*% segment)                if (((0 < ksi[1] && ksi[1] < 1) || (0 < ksi[2] &&                   ksi[2] < 1)) == TRUE) {                  warning("singleintersection::Superimposed edges")                  return(singleintersection)                }            }        }    }    else {        inverse <- matrix(c(vectors2D[2, 2], -vectors2D[2, 1],             vectors2D[1, 2], -vectors2D[1, 1]), nrow = 2, byrow = T)/detv        temp <- pointsij2D[3, ] - pointsij2D[1, ]        ks <- inverse %*% temp        conditionI <- ((0 < ks[1] && ks[1] < 1) && (0 < ks[2] &&             ks[2] < 1))        binary = (kind == "binary")        if (conditionI == TRUE && binary == TRUE) {            singleintersection <- 1            return(singleintersection)        }        if (conditionI == FALSE && binary == TRUE) {            singleintersection <- 0            return(singleintersection)        }        if (conditionI == TRUE && binary == FALSE) {            zs = c(pointsij[1, 3] + ks[1] * vectors3D[1, 3],                 pointsij[3, 3] + ks[2] * vectors3D[2, 3])            sign = sign(zs[1] - zs[2])            Qs = vectors3D            if (sign == 1) {                i <- 1                j <- 2            }            else {                i <- 2                j <- 1            }            Qs[i, ] <- pointsij[2 * i - 1, ] + ks[i] * vectors3D[i,                 ]            Qs[j, ] <- Qs[i, ]            Qs[j, 3] <- zs[j]            singleintersection <- switch(kind, sign = sign, q = list(sign = sign,                 Qs = Qs), k = list(sign = sign, ks = ks[1]),                 ks = list(sign = sign, ks = ks, Qs = Qs), lk = list(sign = sign,                   ks = ks[1], Q2D = Qs[1, 1:2], Qs = Qs), warning("Warning: switched called with uncorrect call option"))            return(singleintersection)        }        if (conditionI == FALSE && binary == FALSE)             singleintersection <- 0    }    return(singleintersection)}        ends[comp:(ncomp - 1)] <- ends[comp:(ncomp - 1)] - (drop -             b)        M <- tempM    }    return(list(points3D = points3D, ends = ends, M = M))}
reduced=msr(protein,c(),100)
ls()
exends
ls()
where
Q
reduced=msr(protein,50,100)
ls()
exends
exends
intervals
n
intervals
n
intervals
c
exends
c
exends
c
exends
c
exends
c
exends
c
exends
c
exends
intervals
n
n
intervals
reduced=msr(protein,50,100)
ls()
n
ls()
n
ls()
intervals
c
ls()
shift
intervals
drop
e
c
ls()
grm <-function (points3D, b, ends, inputM) {    M <- inputM    n <- nrow(points3D)    ncomp <- length(ends) + 1    shift <- 0    if (b >= (n - 1) || (b %in% ends))         return(list(points3D = points3D, ends = ends, M = M))    exends <- c(0, ends, n)    intervals <- list()            for (k in 1:ncomp) intervals[[k]] <- (exends[k] + 1):(exends[k +         1] - 1)    comp <- which(exends - b >= 0)[1] - 1    ecomponent <- exends[comp + 1]    tempM <- M    e <- b    while (e < (ecomponent - 1)) {        sh <- 0        e <- e + 1        range <- b:e        usubM <- M[range, range]        usubM[lower.tri(usubM)] <- 0        if ((min(usubM) * max(usubM) != -1) == TRUE) {            sh <- sh + 1            complement <- list()            for (k in 1:ncomp) complement[[k]] <- M[range, intervals[[k]]]            complement[[comp]] <- complement[[comp]][, intervals[[comp]][-which(intervals[[comp]] %in%                 (b:e) == TRUE)] - if (comp > 0) {                exends[comp]            }            else {                0            }]            complementsigns <- unique(unlist(complement))            if ((min(complementsigns) * max(complementsigns) != -1) == TRUE) {                sh <- sh + 1                temp <- edgeIntersections(points3D, c(1:n)[-((b +                   1):e)], b)                nr <- rep(0, n - 1)                nr[temp[, 1]] <- temp[, 2]                nrtemp <- nr                nrtemp[c(b, e)] <- 0                nrsigns <- unique(nrtemp)                cnd <- c(complementsigns, nrsigns)                if ((min(cnd) * max(cnd) !=                   -1) == TRUE) {                  sh <- sh + 1                  tempM <- M                  tempM[b, ] <- nr                  tempM[, b] <- (-nr)                  tempM <- tempM[-((b + 1):e), -((b + 1):e)]                }                else {                  break                }            }            else {                break            }        }        else {            break        }                    browser() #####################################################################################    }    if (sh == 3)         shift <- 1    drop <- shift + min(e - 1, ecomponent - 2)    if ((b + 1) <= drop) {        points3D <- points3D[-c((b + 1):drop), ]
Q
    browser()
    browser()
Q
grm <-function (points3D, b, ends, inputM) {    M <- inputM    n <- nrow(points3D)    ncomp <- length(ends) + 1    shift <- 0    if (b >= (n - 1) || (b %in% ends))         return(list(points3D = points3D, ends = ends, M = M))    exends <- c(0, ends, n)    intervals <- list()            for (k in 1:ncomp) intervals[[k]] <- (exends[k] + 1):(exends[k +         1] - 1)    comp <- which(exends - b >= 0)[1] - 1    ecomponent <- exends[comp + 1]    tempM <- M    e <- b    while (e < (ecomponent - 1)) {        sh <- 0        e <- e + 1        range <- b:e        usubM <- M[range, range]        usubM[lower.tri(usubM)] <- 0        if ((min(usubM) * max(usubM) != -1) == TRUE) {            sh <- sh + 1            complement <- list()            for (k in 1:ncomp) complement[[k]] <- M[range, intervals[[k]]]            complement[[comp]] <- complement[[comp]][, intervals[[comp]][-which(intervals[[comp]] %in%                 (b:e) == TRUE)] - if (comp > 0) {                exends[comp]            }            else {                0            }]            complementsigns <- unique(unlist(complement))            if ((min(complementsigns) * max(complementsigns) != -1) == TRUE) {                sh <- sh + 1                temp <- edgeIntersections(points3D, c(1:n)[-((b +                   1):e)], b)                nr <- rep(0, n - 1)                nr[temp[, 1]] <- temp[, 2]                nrtemp <- nr                nrtemp[c(b, e)] <- 0                nrsigns <- unique(nrtemp)                cnd <- c(complementsigns, nrsigns)                if ((min(cnd) * max(cnd) !=                   -1) == TRUE) {                  sh <- sh + 1                  tempM <- M                  tempM[b, ] <- nr                  tempM[, b] <- (-nr)                  tempM <- tempM[-((b + 1):e), -((b + 1):e)]                }                else {                  break                }            }            else {                break            }        }        else {            break        }                    browser() #####################################################################################    }    if (sh == 3)         shift <- 1    drop <- shift + min(e - 1, ecomponent - 2)    if ((b + 1) <= drop) {        points3D <- points3D[-c((b + 1):drop), ]
##HEADER##depends on bio3d (pdb import) and on RGL (3d graphics, to keep up) at the moment#To do, check if a class structure is well suited for a protein information set.edgeIntersections <-function (points3D, indiceslist, edgeindex) {    edgeintersections <- c()    maxindex <- length(indiceslist) - 1    if (edgeindex > maxindex)         warning("edgeindex > maxindex, call error")    if (edgeindex >= length(indiceslist))         warning("edgeindex out of bound, call error")    edgeindices <- indiceslist[edgeindex + c(0, 1)]    set <- indiceslist[-length(indiceslist)]    for (i in set) {        pointsij <- points3D[c(edgeindices, i, i + 1), ]        singleintersection <- singleIntersection(pointsij, "sign")        if (singleintersection != 0)             edgeintersections <- rbind(edgeintersections, c(i,                 singleintersection))    }    return(edgeintersections)}fileImport <-function (filename) {    if (missing(filename))         stop("fileImport: argument 'filename' missing, with no default\n")    if (!is.character(filename))         stop("fileImport: argument 'filename' must be string\n")        pdb <- read.pdb(filename)    chains <- unique(pdb$atom[, 5])    if(length(chains)!=1)    {    	cat(c("Available chains\n", chains))    	chain <- readline("Chain to read ")    }    else    {    	chain <- chains    }    pdb$atom <- pdb$atom[pdb$atom[, "chain"] == chain, ]    alphatrace <- pdb$atom[pdb$atom[, "elety"] == "CA", ]    coordinates <- matrix(as.double(alphatrace[, c("x","y","z")]), ncol = 3)    return(coordinates)}grm <-function (points3D, b, ends, inputM) {    M <- inputM    n <- nrow(points3D)    ncomp <- length(ends) + 1    shift <- 0    if (b >= (n - 1) || (b %in% ends))         return(list(points3D = points3D, ends = ends, M = M))    exends <- c(0, ends, n)    intervals <- list()    for (k in 1:ncomp) intervals[[k]] <- (exends[k] + 1):(exends[k +         1] - 1)    comp <- which(exends - b >= 0)[1] - 1    ecomponent <- exends[comp + 1]    tempM <- M    e <- b    while (e < (ecomponent - 1)) {        sh <- 0        e <- e + 1        range <- b:e        usubM <- M[range, range]        usubM[lower.tri(usubM)] <- 0        if ((min(usubM) * max(usubM) != -1) == TRUE) {            sh <- sh + 1            complement <- list()            for (k in 1:ncomp) complement[[k]] <- M[range, intervals[[k]]]            complement[[comp]] <- complement[[comp]][, intervals[[comp]][-which(intervals[[comp]] %in%                 (b:e) == TRUE)] - if (comp > 0) {                exends[comp]            }            else {                0            }]            complementsigns <- unique(unlist(complement))            if ((min(complementsigns) * max(complementsigns) != -1) == TRUE) {                sh <- sh + 1                temp <- edgeIntersections(points3D, c(1:n)[-((b +                   1):e)], b)                nr <- rep(0, n - 1)                nr[temp[, 1]] <- temp[, 2]                nrtemp <- nr                nrtemp[c(b, e)] <- 0                nrsigns <- unique(nrtemp)                cnd <- c(complementsigns, nrsigns)                if ((min(cnd) * max(cnd) !=                   -1) == TRUE) {                  sh <- sh + 1                  tempM <- M                  tempM[b, ] <- nr                  tempM[, b] <- (-nr)                  tempM <- tempM[-((b + 1):e), -((b + 1):e)]                }                else {                  break                }            }            else {                break            }        }        else {            break        }    }    if (sh == 3)         shift <- 1    drop <- shift + min(e - 1, ecomponent - 2)    if ((b + 1) <= drop) {        points3D <- points3D[-c((b + 1):drop), ]        ends[comp:(ncomp - 1)] <- ends[comp:(ncomp - 1)] - (drop -             b)        M <- tempM    }    return(list(points3D = points3D, ends = ends, M = M))}structurePlot <-function (points, ndim, color) {    if (ndim == 2) {        plot(points, type = "n", asp = 1)        lines(points, col = "blue")    }    {        lines3d(lwd = 3.5, color = color, points)        rgl.bringtotop()    }}intersectionMatrix <-function (points3D) {    nedge <- nrow(points3D) - 1    M <- matrix(0, nrow = nedge, ncol = nedge)    lintersectionslist <- list()    for (i in 1:nedge) {        lintersectionslist[[i]] <- edgeIntersections(points3D[1:(i +             1), ], 1:(i + 1), i)    }    nintersectionslist <- unlist(lapply(lintersectionslist, length))/2    intersecting <- which(nintersectionslist != 0)    natleastone <- length(intersecting)    nintersectionslist <- nintersectionslist[intersecting]    for (i in 1:natleastone) {        for (j in 1:nintersectionslist[i]) {            M[intersecting[i], lintersectionslist[[intersecting[i]]][j,                 1]] <- lintersectionslist[[intersecting[i]]][j,                 2]        }    }    return(M - t(M))}msr <-function (points3D, ends, n) {    M <- intersectionMatrix(points3D)    cat("matrix computed\n")    l <- quote(nrow(points3D))    k <- length(ends) + 1    for (i in 1:n) {        if (eval(l) <= 2 * k)             break        p <- nrow(points3D)        for (b in 1:(eval(l) - 1)) {            temp <- grm(points3D, b, ends, M)            points3D <- temp$points3D            ends <- temp$ends            M <- temp$M        }        if (p == eval(l))             break    }    return(list(points3D = points3D, ends = ends))}singleIntersection <-function (pointsij, kind) {    singleintersection <- 0    pointsij2D <- pointsij[, c(1, 2)]    vectors3D <- matrix(c(pointsij[2, ] - pointsij[1, ], pointsij[4,         ] - pointsij[3, ]), nrow = 2, byrow = T)    vectors2D <- vectors3D[, c(1, 2)]    if (nrow(unique(pointsij)) <= 3) {        return(singleintersection)    }    detv <- det(vectors2D)    if ((detv == 0) == TRUE) {        if (pointsij[1, ] == pointsij[2, ] || pointsij[3, ] ==             pointsij[4, ]) {            print("singleintersection::Exit due to collapsed edge")            return(singleintersection)        }        else {            if (rankMatrix(t(rbind(vectors2D, pointsij2D[3, ] -                 pointsij2D[1, ]))) == 1) {                ksi <- c(0, 0)                segment <- pointsij2D[2, ] - pointsij2D[1, ]                for (i in 1:2) ksi[i] <- segment %*% (pointsij2D[i +                   2, ] - pointsij2D[1, ])/(segment %*% segment)                if (((0 < ksi[1] && ksi[1] < 1) || (0 < ksi[2] &&                   ksi[2] < 1)) == TRUE) {                  warning("singleintersection::Superimposed edges")                  return(singleintersection)                }            }        }    }    else {        inverse <- matrix(c(vectors2D[2, 2], -vectors2D[2, 1],             vectors2D[1, 2], -vectors2D[1, 1]), nrow = 2, byrow = T)/detv        temp <- pointsij2D[3, ] - pointsij2D[1, ]        ks <- inverse %*% temp        conditionI <- ((0 < ks[1] && ks[1] < 1) && (0 < ks[2] &&             ks[2] < 1))        binary = (kind == "binary")        if (conditionI == TRUE && binary == TRUE) {            singleintersection <- 1            return(singleintersection)        }        if (conditionI == FALSE && binary == TRUE) {            singleintersection <- 0            return(singleintersection)        }        if (conditionI == TRUE && binary == FALSE) {            zs = c(pointsij[1, 3] + ks[1] * vectors3D[1, 3],                 pointsij[3, 3] + ks[2] * vectors3D[2, 3])            sign = sign(zs[1] - zs[2])            Qs = vectors3D            if (sign == 1) {                i <- 1                j <- 2            }            else {                i <- 2                j <- 1            }            Qs[i, ] <- pointsij[2 * i - 1, ] + ks[i] * vectors3D[i,                 ]            Qs[j, ] <- Qs[i, ]            Qs[j, 3] <- zs[j]            singleintersection <- switch(kind, sign = sign, q = list(sign = sign,                 Qs = Qs), k = list(sign = sign, ks = ks[1]),                 ks = list(sign = sign, ks = ks, Qs = Qs), lk = list(sign = sign,                   ks = ks[1], Q2D = Qs[1, 1:2], Qs = Qs), warning("Warning: switched called with uncorrect call option"))            return(singleintersection)        }        if (conditionI == FALSE && binary == FALSE)             singleintersection <- 0    }    return(singleintersection)}        ends[comp:(ncomp - 1)] <- ends[comp:(ncomp - 1)] - (drop -             b)        M <- tempM    }    return(list(points3D = points3D, ends = ends, M = M))}
##HEADER##depends on bio3d (pdb import) and on RGL (3d graphics, to keep up) at the moment#To do, check if a class structure is well suited for a protein information set.edgeIntersections <-function (points3D, indiceslist, edgeindex) {    edgeintersections <- c()    maxindex <- length(indiceslist) - 1    if (edgeindex > maxindex)         warning("edgeindex > maxindex, call error")    if (edgeindex >= length(indiceslist))         warning("edgeindex out of bound, call error")    edgeindices <- indiceslist[edgeindex + c(0, 1)]    set <- indiceslist[-length(indiceslist)]    for (i in set) {        pointsij <- points3D[c(edgeindices, i, i + 1), ]        singleintersection <- singleIntersection(pointsij, "sign")        if (singleintersection != 0)             edgeintersections <- rbind(edgeintersections, c(i,                 singleintersection))    }    return(edgeintersections)}fileImport <-function (filename) {    if (missing(filename))         stop("fileImport: argument 'filename' missing, with no default\n")    if (!is.character(filename))         stop("fileImport: argument 'filename' must be string\n")        pdb <- read.pdb(filename)    chains <- unique(pdb$atom[, 5])    if(length(chains)!=1)    {    	cat(c("Available chains\n", chains))    	chain <- readline("Chain to read ")    }    else    {    	chain <- chains    }    pdb$atom <- pdb$atom[pdb$atom[, "chain"] == chain, ]    alphatrace <- pdb$atom[pdb$atom[, "elety"] == "CA", ]    coordinates <- matrix(as.double(alphatrace[, c("x","y","z")]), ncol = 3)    return(coordinates)}grm <-function (points3D, b, ends, inputM) {    M <- inputM    n <- nrow(points3D)    ncomp <- length(ends) + 1    shift <- 0    if (b >= (n - 1) || (b %in% ends))         return(list(points3D = points3D, ends = ends, M = M))    exends <- c(0, ends, n)    intervals <- list()    for (k in 1:ncomp) intervals[[k]] <- (exends[k] + 1):(exends[k +         1] - 1)    comp <- which(exends - b >= 0)[1] - 1    ecomponent <- exends[comp + 1]    tempM <- M    e <- b    while (e < (ecomponent - 1)) {        sh <- 0        e <- e + 1        range <- b:e        usubM <- M[range, range]        usubM[lower.tri(usubM)] <- 0        if ((min(usubM) * max(usubM) != -1) == TRUE) {            sh <- sh + 1            complement <- list()            for (k in 1:ncomp) complement[[k]] <- M[range, intervals[[k]]]            complement[[comp]] <- complement[[comp]][, intervals[[comp]][-which(intervals[[comp]] %in%                 (b:e) == TRUE)] - if (comp > 0) {                exends[comp]            }            else {                0            }]            complementsigns <- unique(unlist(complement))            if ((min(complementsigns) * max(complementsigns) != -1) == TRUE) {                sh <- sh + 1                temp <- edgeIntersections(points3D, c(1:n)[-((b +                   1):e)], b)                nr <- rep(0, n - 1)                nr[temp[, 1]] <- temp[, 2]                nrtemp <- nr                nrtemp[c(b, e)] <- 0                nrsigns <- unique(nrtemp)                cnd <- c(complementsigns, nrsigns)                if ((min(cnd) * max(cnd) !=                   -1) == TRUE) {                  sh <- sh + 1                  tempM <- M                  tempM[b, ] <- nr                  tempM[, b] <- (-nr)                  tempM <- tempM[-((b + 1):e), -((b + 1):e)]                }                else {                  break                }            }            else {                break            }        }        else {            break        }    }    if (sh == 3)         shift <- 1    drop <- shift + min(e - 1, ecomponent - 2)    if ((b + 1) <= drop) {        points3D <- points3D[-c((b + 1):drop), ]        ends[comp:(ncomp - 1)] <- ends[comp:(ncomp - 1)] - (drop -             b)        M <- tempM    }    return(list(points3D = points3D, ends = ends, M = M))}structurePlot <-function (points, ndim, color) {    if (ndim == 2) {        plot(points, type = "n", asp = 1)        lines(points, col = "blue")    }    {        lines3d(lwd = 3.5, color = color, points)        rgl.bringtotop()    }}intersectionMatrix <-function (points3D) {    nedge <- nrow(points3D) - 1    M <- matrix(0, nrow = nedge, ncol = nedge)    lintersectionslist <- list()    for (i in 1:nedge) {        lintersectionslist[[i]] <- edgeIntersections(points3D[1:(i +             1), ], 1:(i + 1), i)    }    nintersectionslist <- unlist(lapply(lintersectionslist, length))/2    intersecting <- which(nintersectionslist != 0)    natleastone <- length(intersecting)    nintersectionslist <- nintersectionslist[intersecting]    for (i in 1:natleastone) {        for (j in 1:nintersectionslist[i]) {            M[intersecting[i], lintersectionslist[[intersecting[i]]][j,                 1]] <- lintersectionslist[[intersecting[i]]][j,                 2]        }    }    return(M - t(M))}msr <-function (points3D, ends, n) {    M <- intersectionMatrix(points3D)    cat("matrix computed\n")    l <- quote(nrow(points3D))    k <- length(ends) + 1    for (i in 1:n) {        if (eval(l) <= 2 * k)             break        p <- nrow(points3D)        for (b in 1:(eval(l) - 1)) {            temp <- grm(points3D, b, ends, M)            points3D <- temp$points3D            ends <- temp$ends            M <- temp$M        }        if (p == eval(l))             break    }    return(list(points3D = points3D, ends = ends))}singleIntersection <-function (pointsij, kind) {    singleintersection <- 0    pointsij2D <- pointsij[, c(1, 2)]    vectors3D <- matrix(c(pointsij[2, ] - pointsij[1, ], pointsij[4,         ] - pointsij[3, ]), nrow = 2, byrow = T)    vectors2D <- vectors3D[, c(1, 2)]    if (nrow(unique(pointsij)) <= 3) {        return(singleintersection)    }    detv <- det(vectors2D)    if ((detv == 0) == TRUE) {        if (pointsij[1, ] == pointsij[2, ] || pointsij[3, ] ==             pointsij[4, ]) {            print("singleintersection::Exit due to collapsed edge")            return(singleintersection)        }        else {            if (rankMatrix(t(rbind(vectors2D, pointsij2D[3, ] -                 pointsij2D[1, ]))) == 1) {                ksi <- c(0, 0)                segment <- pointsij2D[2, ] - pointsij2D[1, ]                for (i in 1:2) ksi[i] <- segment %*% (pointsij2D[i +                   2, ] - pointsij2D[1, ])/(segment %*% segment)                if (((0 < ksi[1] && ksi[1] < 1) || (0 < ksi[2] &&                   ksi[2] < 1)) == TRUE) {                  warning("singleintersection::Superimposed edges")                  return(singleintersection)                }            }        }    }    else {        inverse <- matrix(c(vectors2D[2, 2], -vectors2D[2, 1],             vectors2D[1, 2], -vectors2D[1, 1]), nrow = 2, byrow = T)/detv        temp <- pointsij2D[3, ] - pointsij2D[1, ]        ks <- inverse %*% temp        conditionI <- ((0 < ks[1] && ks[1] < 1) && (0 < ks[2] &&             ks[2] < 1))        binary = (kind == "binary")        if (conditionI == TRUE && binary == TRUE) {            singleintersection <- 1            return(singleintersection)        }        if (conditionI == FALSE && binary == TRUE) {            singleintersection <- 0            return(singleintersection)        }        if (conditionI == TRUE && binary == FALSE) {            zs = c(pointsij[1, 3] + ks[1] * vectors3D[1, 3],                 pointsij[3, 3] + ks[2] * vectors3D[2, 3])            sign = sign(zs[1] - zs[2])            Qs = vectors3D            if (sign == 1) {                i <- 1                j <- 2            }            else {                i <- 2                j <- 1            }            Qs[i, ] <- pointsij[2 * i - 1, ] + ks[i] * vectors3D[i,                 ]            Qs[j, ] <- Qs[i, ]            Qs[j, 3] <- zs[j]            singleintersection <- switch(kind, sign = sign, q = list(sign = sign,                 Qs = Qs), k = list(sign = sign, ks = ks[1]),                 ks = list(sign = sign, ks = ks, Qs = Qs), lk = list(sign = sign,                   ks = ks[1], Q2D = Qs[1, 1:2], Qs = Qs), warning("Warning: switched called with uncorrect call option"))            return(singleintersection)        }        if (conditionI == FALSE && binary == FALSE)             singleintersection <- 0    }    return(singleintersection)}        ends[comp:(ncomp - 1)] <- ends[comp:(ncomp - 1)] - (drop -             b)        M <- tempM    }    return(list(points3D = points3D, ends = ends, M = M))}
##HEADER##depends on bio3d (pdb import) and on RGL (3d graphics, to keep up) at the moment#To do, check if a class structure is well suited for a protein information set.edgeIntersections <-function (points3D, indiceslist, edgeindex) {    edgeintersections <- c()    maxindex <- length(indiceslist) - 1    if (edgeindex > maxindex)         warning("edgeindex > maxindex, call error")    if (edgeindex >= length(indiceslist))         warning("edgeindex out of bound, call error")    edgeindices <- indiceslist[edgeindex + c(0, 1)]    set <- indiceslist[-length(indiceslist)]    for (i in set) {        pointsij <- points3D[c(edgeindices, i, i + 1), ]        singleintersection <- singleIntersection(pointsij, "sign")        if (singleintersection != 0)             edgeintersections <- rbind(edgeintersections, c(i,                 singleintersection))    }    return(edgeintersections)}fileImport <-function (filename) {    if (missing(filename))         stop("fileImport: argument 'filename' missing, with no default\n")    if (!is.character(filename))         stop("fileImport: argument 'filename' must be string\n")        pdb <- read.pdb(filename)    chains <- unique(pdb$atom[, 5])    if(length(chains)!=1)    {    	cat(c("Available chains\n", chains))    	chain <- readline("Chain to read ")    }    else    {    	chain <- chains    }    pdb$atom <- pdb$atom[pdb$atom[, "chain"] == chain, ]    alphatrace <- pdb$atom[pdb$atom[, "elety"] == "CA", ]    coordinates <- matrix(as.double(alphatrace[, c("x","y","z")]), ncol = 3)    return(coordinates)}grm <-function (points3D, b, ends, inputM) {    M <- inputM    n <- nrow(points3D)    ncomp <- length(ends) + 1    shift <- 0    if (b >= (n - 1) || (b %in% ends))         return(list(points3D = points3D, ends = ends, M = M))    exends <- c(0, ends, n)    intervals <- list()    for (k in 1:ncomp) intervals[[k]] <- (exends[k] + 1):(exends[k +         1] - 1)    comp <- which(exends - b >= 0)[1] - 1    ecomponent <- exends[comp + 1]    tempM <- M    e <- b    while (e < (ecomponent - 1)) {        sh <- 0        e <- e + 1        range <- b:e        usubM <- M[range, range]        usubM[lower.tri(usubM)] <- 0        if ((min(usubM) * max(usubM) != -1) == TRUE) {            sh <- sh + 1            complement <- list()            for (k in 1:ncomp) complement[[k]] <- M[range, intervals[[k]]]            complement[[comp]] <- complement[[comp]][, intervals[[comp]][-which(intervals[[comp]] %in%                 (b:e) == TRUE)] - if (comp > 0) {                exends[comp]            }            else {                0            }]            complementsigns <- unique(unlist(complement))            if ((min(complementsigns) * max(complementsigns) != -1) == TRUE) {                sh <- sh + 1                temp <- edgeIntersections(points3D, c(1:n)[-((b +                   1):e)], b)                nr <- rep(0, n - 1)                nr[temp[, 1]] <- temp[, 2]                nrtemp <- nr                nrtemp[c(b, e)] <- 0                nrsigns <- unique(nrtemp)                cnd <- c(complementsigns, nrsigns)                if ((min(cnd) * max(cnd) !=                   -1) == TRUE) {                  sh <- sh + 1                  tempM <- M                  tempM[b, ] <- nr                  tempM[, b] <- (-nr)                  tempM <- tempM[-((b + 1):e), -((b + 1):e)]                }                else {                  break                }            }            else {                break            }        }        else {            break        }    }    if (sh == 3)         shift <- 1    drop <- shift + min(e - 1, ecomponent - 2)    if ((b + 1) <= drop) {        points3D <- points3D[-c((b + 1):drop), ]        ends[comp:(ncomp - 1)] <- ends[comp:(ncomp - 1)] - (drop -             b)        M <- tempM    }    return(list(points3D = points3D, ends = ends, M = M))}structurePlot <-function (points, ndim, color) {    if (ndim == 2) {        plot(points, type = "n", asp = 1)        lines(points, col = "blue")    }    {        lines3d(lwd = 3.5, color = color, points)        rgl.bringtotop()    }}intersectionMatrix <-function (points3D) {    nedge <- nrow(points3D) - 1    M <- matrix(0, nrow = nedge, ncol = nedge)    lintersectionslist <- list()    for (i in 1:nedge) {        lintersectionslist[[i]] <- edgeIntersections(points3D[1:(i +             1), ], 1:(i + 1), i)    }    nintersectionslist <- unlist(lapply(lintersectionslist, length))/2    intersecting <- which(nintersectionslist != 0)    natleastone <- length(intersecting)    nintersectionslist <- nintersectionslist[intersecting]    for (i in 1:natleastone) {        for (j in 1:nintersectionslist[i]) {            M[intersecting[i], lintersectionslist[[intersecting[i]]][j,                 1]] <- lintersectionslist[[intersecting[i]]][j,                 2]        }    }    return(M - t(M))}msr <-function (points3D, ends, n) {    M <- intersectionMatrix(points3D)    cat("matrix computed\n")    l <- quote(nrow(points3D))    k <- length(ends) + 1    for (i in 1:n) {        if (eval(l) <= 2 * k)             break        p <- nrow(points3D)        for (b in 1:(eval(l) - 1)) {            temp <- grm(points3D, b, ends, M)            points3D <- temp$points3D            ends <- temp$ends            M <- temp$M        }        if (p == eval(l))             break    }    return(list(points3D = points3D, ends = ends))}singleIntersection <-function (pointsij, kind) {    singleintersection <- 0    pointsij2D <- pointsij[, c(1, 2)]    vectors3D <- matrix(c(pointsij[2, ] - pointsij[1, ], pointsij[4,         ] - pointsij[3, ]), nrow = 2, byrow = T)    vectors2D <- vectors3D[, c(1, 2)]    if (nrow(unique(pointsij)) <= 3) {        return(singleintersection)    }    detv <- det(vectors2D)    if ((detv == 0) == TRUE) {        if (pointsij[1, ] == pointsij[2, ] || pointsij[3, ] ==             pointsij[4, ]) {            print("singleintersection::Exit due to collapsed edge")            return(singleintersection)        }        else {            if (rankMatrix(t(rbind(vectors2D, pointsij2D[3, ] -                 pointsij2D[1, ]))) == 1) {                ksi <- c(0, 0)                segment <- pointsij2D[2, ] - pointsij2D[1, ]                for (i in 1:2) ksi[i] <- segment %*% (pointsij2D[i +                   2, ] - pointsij2D[1, ])/(segment %*% segment)                if (((0 < ksi[1] && ksi[1] < 1) || (0 < ksi[2] &&                   ksi[2] < 1)) == TRUE) {                  warning("singleintersection::Superimposed edges")                  return(singleintersection)                }            }        }    }    else {        inverse <- matrix(c(vectors2D[2, 2], -vectors2D[2, 1],             vectors2D[1, 2], -vectors2D[1, 1]), nrow = 2, byrow = T)/detv        temp <- pointsij2D[3, ] - pointsij2D[1, ]        ks <- inverse %*% temp        conditionI <- ((0 < ks[1] && ks[1] < 1) && (0 < ks[2] &&             ks[2] < 1))        binary = (kind == "binary")        if (conditionI == TRUE && binary == TRUE) {            singleintersection <- 1            return(singleintersection)        }        if (conditionI == FALSE && binary == TRUE) {            singleintersection <- 0            return(singleintersection)        }        if (conditionI == TRUE && binary == FALSE) {            zs = c(pointsij[1, 3] + ks[1] * vectors3D[1, 3],                 pointsij[3, 3] + ks[2] * vectors3D[2, 3])            sign = sign(zs[1] - zs[2])            Qs = vectors3D            if (sign == 1) {                i <- 1                j <- 2            }            else {                i <- 2                j <- 1            }            Qs[i, ] <- pointsij[2 * i - 1, ] + ks[i] * vectors3D[i,                 ]            Qs[j, ] <- Qs[i, ]            Qs[j, 3] <- zs[j]            singleintersection <- switch(kind, sign = sign, q = list(sign = sign,                 Qs = Qs), k = list(sign = sign, ks = ks[1]),                 ks = list(sign = sign, ks = ks, Qs = Qs), lk = list(sign = sign,                   ks = ks[1], Q2D = Qs[1, 1:2], Qs = Qs), warning("Warning: switched called with uncorrect call option"))            return(singleintersection)        }        if (conditionI == FALSE && binary == FALSE)             singleintersection <- 0    }    return(singleintersection)}
